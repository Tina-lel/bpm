#!/bin/bash
#===============================================================================
# bpm - A Bash-based System Package Manager
# Authors: Tina-lel and Justus0405
# License: GNU General Public License v2.0
# Upstream: https://github.com/Tina-lel/bpm
# Dependencies : bash, curl, tar, gzip
#
# bpm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License v2.0 for more details.
#
# You should have received a copy of the
# GNU General Public License v2.0 along with bpm.
# If not, see <https://www.gnu.org/licenses/>.
#
# Tina was here
#===============================================================================

# Global Variables
export VERSION="0.1"
export DIRMAIN="$HOME/.config/bpm"

# Color variables
export RED="\e[1;31m"
export GREEN="\e[1;32m"
export YELLOW="\e[1;33m"
export CYAN="\e[1;36m"
export GRAY="\e[1;90m"
export ENDCOLOR="\e[0m"

# Info variables
export SUCCSESS="${GRAY}[${GREEN}✓${GRAY}]${ENDCOLOR}"
export ERROR="${RED}Error:${ENDCOLOR}"
export WARNING="${GRAY}[${RED}!${GRAY}]${ENDCOLOR}"
export SECTION="${GRAY}[${YELLOW}!${GRAY}]${ENDCOLOR}"
export INFO="${GRAY}[${CYAN}i${GRAY}]${ENDCOLOR}"

# FUNCTIONS

# Creates config incase it doesnt exist and sources config file
create_conf() {
    if [[ ! -d "$DIRMAIN" ]]; then
        mkdir -p "$DIRMAIN"
        mkdir -p "$DIRMAIN/index"
        touch "$DIRMAIN/bpm.conf"

        echo "# Created by bpm on $(date '+%Y\%m\%d')" >>"$DIRMAIN/bpm.conf"
        echo "" >>"$DIRMAIN/bpm.conf"
        echo "REPO=\"\"" >>"$DIRMAIN/bpm.conf"
        echo "WORKING_DIR=\"$HOME/.cache/bpm\"" >>"$DIRMAIN/bpm.conf"
    fi
}

exec_conf() {
    if [[ -f "$DIRMAIN/bpm.conf" ]]; then
        source "$DIRMAIN/bpm.conf"
    else
        echo -e "${ERROR} no config file in $DIRMAIN, use \"bpm config\" to generate one"
        exit 1
    fi
}

check_args() {
    case $1 in
    "add")
        exec_conf
        shift
        add_packages "$@"
        ;;
    "del")
        exec_conf
        shift
        del_packages "$@"
        ;;
    "update")
        exec_conf
        update_packagelist
        ;;
    "upgrade")
        exec_conf
        upgrade_package
        ;;
    "config")
        create_conf
        ;;
    "search")
        exec_conf
        shift
        search_package "$1"
        ;;
    "info")
        exec_conf
        shift
        info_package "$1"
        ;;
    "list")
        exec_conf
        info_packagelist
        ;;
    "index")
        info_index
        ;;
    "help")
        help_message
        ;;
    "version")
        version_message
        ;;
    "")
        echo -e "${ERROR} no operation specified"
        exit 1
        ;;
    *)
        echo -e "${ERROR} unrecognized option '$1'"
        exit 1
        ;;
    esac
}

add_packages() {
    if [[ $1 == "" ]]; then
        echo -e "${ERROR} no targets specified."
        exit 1
    elif [[ -f "$DIRMAIN/index/$1" ]]; then
        echo -e "${SECTION} package already installed, reinstalling..."
    fi

    local packages=("$@")
    local package_amount=${#packages[@]}

    # This checks wether or not the specified package name is available at the
    # remote repo via an http code (200 means downloadable, so continue)
    for package_check in "${packages[@]}"; do
        AVAILABILITY=$(curl -o /dev/null --silent -Iw "%{http_code}" "$REPO/info/$package_check.info")
        if [[ "$AVAILABILITY" != "200" ]]; then
            echo -e "${ERROR} Cant download package info for '$package_check'"
            exit 1
        fi
    done

    echo -e ""
    echo -e "${INFO} Packages ($package_amount): ${packages[*]}"
    echo -e ""
    read -rp "Proceed with installation? [Y/n] " confirm
    case "$confirm" in
    [nN])
        echo -e "${RED}Aborted.${ENDCOLOR}"
        exit 0
        ;;
    *)
        for package_inst in "${packages[@]}"; do
            echo -e "${SECTION} Installing $package_inst"
            install_package "$package_inst"
        done
        ;;
    esac
}

install_package() {
    local package="$1"
    set +e

    mkdir -p "$WORKING_DIR"
    cd "$WORKING_DIR" || {
        echo -e "${ERROR} could not enter temp path"
        exit 1
    }

    echo -e "${INFO} Downloading package..."
    curl -s -o "$package.info" "$REPO/info/$package.info"
    source "$package.info" >/dev/null 2>&1
    curl -s -o "$package.tar.gz" "$REPO/$SORT/$package.tar.gz"

    echo -e "${INFO} Verifying checksum..."
    cat "$package.info" | tail -n 1 | md5sum --quiet -c - || {
        echo -e "${ERROR} Checksum missmatch"
        exit 1
    }

    echo -e "${INFO} Extracting package..."
    tar -xzf "$package.tar.gz"
    PKG_DIR="$WORKING_DIR/$package"

    echo -e "${INFO} Loading build info..."
    source "$PKG_DIR/pkg_info"
    set -e

    if [[ "$DOWNLOAD" == "true" ]]; then
        echo -e "${INFO} Downloading source..."
        DOWNLOAD_SRC
    fi

    if [[ "$COMPILE" == "true" ]]; then
        echo -e "${INFO} Compiling source..."
        COMPILE_SRC
    fi

    echo -e "${INFO} Installing package..."
    if [[ "$ROOT_FOR_INSTALL" == "true" ]]; then
        # this might be a security vulnurability, but its better than before xd
        sudo bash -c "$(declare); INSTALL_PKG" 2>/dev/null
    else
        INSTALL_PKG
    fi

    echo "INSTALLED_FILES=(${INSTALLED_FILES[*]})" >"$DIRMAIN/index/$package"
    echo "ROOT_FOR_INSTALL=$ROOT_FOR_INSTALL" >>"$DIRMAIN/index/$package"

    echo -e "${INFO} Cleaning up...\n"
    cd "$WORKING_DIR" || {
        echo -e "${ERROR} could not enter temp path"
        exit 1
    }
    rm -rf "$package.tar.gz" "$package.info" "$package"
}

del_packages() {
    if [[ $1 == "" ]]; then
        echo -e "${ERROR} no targets specified."
        exit 1
    elif [[ ! -f "$DIRMAIN/index/$1" ]]; then
        echo -e "${ERROR} package not installed"
        exit 1
    fi

    local packages=("$@")
    local package_amount=${#packages[@]}

    echo -e ""
    echo -e "${WARNING} Packages ($package_amount): ${packages[*]}"
    echo -e ""
    read -rp "Proceed with removal? [y/N] " confirm
    case "$confirm" in
    [yY])
        for package_del in "${packages[@]}"; do
            echo -e "${SECTION} Removing $package_del"
            remove_package "$package_del"
        done
        ;;
    *)
        echo -e "${RED}Aborted.${ENDCOLOR}"
        exit 0
        ;;
    esac
}

remove_package() {
    local package="$1"
    source "$DIRMAIN/index/$package"

    if [[ "${#INSTALLED_FILES[@]}" == 0 ]]; then
        echo -e "${ERROR} No files to delete"
    fi

    if [[ "$ROOT_FOR_INSTALL" == "true" ]]; then
        for file_del in "${INSTALLED_FILES[@]}"; do
            echo -e "${WARNING} Deleting $file_del"
            sudo rm -rf "$file_del"
        done
    else
        for file_del in "${INSTALLED_FILES[@]}"; do
            echo -e "${WARNING} Deleting $file_del"
            rm -rf "$file_del"
        done
    fi

    echo -e "${WARNING} Deleting index for $package"
    rm -rf "$DIRMAIN/index/$package"
}

search_package() {
    if [[ $1 == "" ]]; then
        echo -e "${ERROR} no package specified."
        exit 1
    fi
    local package="$1"
    echo -e "${INFO} Searching for $package"
    curl --silent "$REPO/info"/ | grep -o 'href=".*">' | sed -e "s/href=\"//g" | sed -e 's/">//g' | tail -n +2 | cut -d '.' -f1 | grep "$package"
}

info_package() {
    if [[ $1 == "" ]]; then
        echo -e "${ERROR} no package specified."
        exit 1
    fi
    local package="$1"

    AVAILABILITY_INFO=$(curl -o /dev/null --silent -Iw "%{http_code}" "$REPO/info/$package.info")
    if [[ "$AVAILABILITY_INFO" != "200" ]]; then
        echo -e "${ERROR} Cant download info for '$package'"
        exit 1
    fi
    echo -e "${INFO} Info for $package"
    curl --silent "$REPO/info/$package.info"
}

info_packagelist() {
    echo -e "${INFO} Listing of $REPO\n"
    curl --silent "$REPO/info"/ | grep -o 'href=".*">' | sed -e "s/href=\"//g" | sed -e 's/">//g' | tail -n +2 | cut -d '.' -f1
}

info_index() {
    echo -e "${INFO} Listing installed Packages\n"
    ls -1 "$DIRMAIN/index"
}

help_message() {
    echo -e "usage:  bpm <operation> [...]"
    echo -e "operations:"
    echo -e "    bpm add     [package(s)]"
    echo -e "    bpm del     [package(s)]"
    echo -e "    bpm update"
    echo -e "    bpm upgrade"
    echo -e "    bpm config"
    echo -e "    bpm search  [package]"
    echo -e "    bpm info    [package]"
    echo -e "    bpm list"
    echo -e "    bpm index"
    echo -e "    bpm help"
    echo -e "    bpm version"
    echo -e ""
    exit 0
}

version_message() {
    echo -e ""
    echo -e "───▄▄▄         bpm v$VERSION - bash 5.2.37"
    echo -e "─▄▀░▄░▀▄       Copyright (C) 2024-present Tina-lel"
    echo -e "─█░█▄▀░█       Copyright (C) 2024-present Justus0405"
    echo -e "─█░▀▄▄▀█▄█▄▀"
    echo -e "▄▄█▄▄▄▄███▀    This program may be freely redistributed under"
    echo -e "               the terms of the GNU General Public License v2.0"
    echo -e ""
    exit 0
}

# PROGRAM START

check_args "$@"
