#!/bin/bash
#===============================================================================
# bpm - A Bash-based System Package Manager
# Authors: Tina-lel and Justus0405
# License: GNU General Public License v2.0
# Upstream: https://github.com/Tina-lel/bpm
# Dependencies : bash, curl, tar, gzip
#
# bpm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License v2.0 for more details.
#
# You should have received a copy of the
# GNU General Public License v2.0 along with bpm.
# If not, see <https://www.gnu.org/licenses/>.
#
# Tina was here
#===============================================================================

# Global Variables
export VERSION="0.1"

# Color variables
export RED="\e[1;31m"
export GREEN="\e[1;32m"
export YELLOW="\e[1;33m"
export CYAN="\e[1;36m"
export GRAY="\e[1;90m"
export ENDCOLOR="\e[0m"

# Info variables
export SUCCSESS="${GRAY}[${GREEN}âœ“${GRAY}]${ENDCOLOR}"
export ERROR="${RED}Error:${ENDCOLOR}"
export SECTION="${GRAY}[${YELLOW}!${GRAY}]${ENDCOLOR}"
export INFO="${GRAY}[${CYAN}i${GRAY}]${ENDCOLOR}"

# FUNCTIONS

# Creates config incase it doesnt exist and sources config file
check_conf() {
    DIRMAIN="$HOME/.config/bpm"
    if [[ ! -d "$DIRMAIN" ]]; then
        mkdir -p "$DIRMAIN"
        touch "$DIRMAIN/bpm.conf"

        echo "# Created by bpm on $(date '+%Y\%m\%d')" >>"$DIRMAIN/bpm.conf"
        echo "" >>"$DIRMAIN/bpm.conf"
        echo "REPO=\"\"" >>"$DIRMAIN/bpm.conf"
        echo "WORKING_DIR=\"$HOME/.cache/bpm\"" >>"$DIRMAIN/bpm.conf"
    fi
    source "$DIRMAIN/bpm.conf"
}

check_args() {
    # Initialize mode flags for different operations
    MODE_INSTALL=false
    MODE_REMOVE=false
    MODE_UPGRADE=false
    MODE_SEARCH=false
    PACKAGE_NAMES=() # Array to store package names (positional arguments)

    # Loop through all the arguments passed to the script
    while [[ "$1" != "" ]]; do
        case "$1" in
        "-h" | "--help")
            # Help flag: show usage instructions
            MODE=HELP
            ;;
        "-v" | "--version")
            # Version mode: used to display the program version
            MODE=VERSION
            ;;
        "-i" | "--install")
            # Install mode: activate the install flag
            MODE_INSTALL=true
            MODE=INSTALL
            ;;
        "-r" | "--remove")
            # Remove mode: activate the remove flag
            MODE_REMOVE=true
            MODE=REMOVE
            ;;
        "-u" | "--upgrade")
            # Upgrade mode: activate the upgrade flag
            MODE_UPGRADE=true
            MODE=UPGRADE
            ;;
        "-s" | "--search")
            # Search mode: activate the search flag
            MODE_SEARCH=true
            MODE=SEARCH
            ;;
        "-l" | "--list")
            # List mode: used to list available packages
            MODE=LIST
            ;;
        -*)
            # Handle combined flags like -iu (multiple flags in one argument)
            #
            # If the argument starts with a single dash and is followed by letters,
            # treat each letter as a separate flag (e.g., -iu -> -i and -u).
            if [[ "$1" =~ ^-([a-zA-Z]+)$ ]]; then
                # Extract the flags by removing the leading dash
                FLAGS="${1:1}"
                # Iterate over each flag (character) in the combined flag
                for FLAG in $(echo "$FLAGS" | grep -o .); do
                    case "$FLAG" in
                    "h" | "v")
                        # Show help menu when -hv or -vh is used (same behavior as pacman lol)
                        MODE=HELP
                        ;;
                    "i")
                        # Activate install mode if "i" flag is found
                        MODE_INSTALL=true
                        MODE=INSTALL
                        ;;
                    "r")
                        # Activate remove mode if "r" flag is found
                        MODE_REMOVE=true
                        MODE=REMOVE
                        ;;
                    "u")
                        # Activate upgrade mode if "u" flag is found
                        MODE_UPGRADE=true
                        MODE=UPGRADE
                        ;;
                    "s")
                        # Activate search mode if "s" flag is found
                        MODE_SEARCH=true
                        MODE=SEARCH
                        ;;
                    *)
                        echo "bpm: unrecognized option '-$FLAG'"
                        exit 1
                        ;;
                    esac
                done
            else
                echo "bpm: unrecognized option '$1'"
                exit 1
            fi
            ;;
        *)
            # Assume positional arguments are package names
            #
            # If the argument doesn't start with a dash, treat it as a package name.
            # Append the package name to the PACKAGE_NAMES array for later use.
            PACKAGE_NAMES+=("$1")
            ;;
        esac
        shift
    done

    # Validation for conflicting modes
    if [[ "$MODE_SEARCH" == "true" ]]; then
        # Search mode can only be used with exactly one package
        if [[ "${#PACKAGE_NAMES[@]}" -ne 1 ]]; then
            echo -e "${ERROR} missing package name or more than two defined."
            exit 1
        fi
    fi

    # Ensure at least one action (install, remove, upgrade, etc.) is specified
    if [[ "$MODE_INSTALL" == "false" && "$MODE_REMOVE" == "false" && "$MODE_UPGRADE" == "false" && "$MODE_SEARCH" == "false" && "$MODE" = "" ]]; then
        echo -e "${ERROR} no operation specified (use -h for help)"
        exit 1
    fi
}

# PROGRAM START

# A little suprise tool that will help us later :3
#if [[ "$EUID" -ne 0 ]]; then
#    echo "${ERROR} you cannot perform this operation unless you are root."
#    exit 1
#fi

check_conf
check_args "$@"

# Handles the modes given by the check_args function for further processing
case "$MODE" in
"HELP")
    echo -e "usage:  bpm <operation> [...]"
    echo -e "operations:"
    echo -e "    bpm {-h --help}"
    echo -e "    bpm {-v --version}"
    echo -e "    bpm {-i --install} [package(s)]"
    echo -e "    bpm {-r --remove}  [package(s)]"
    echo -e "    bpm {-u --upgrade} [package(s)]"
    echo -e "    bpm {-s --search}  [package]"
    echo -e "    bpm {-l --list}"
    echo -e ""
    exit 0
    ;;
"VERSION")
    echo -e "\tbpm v$VERSION - bash 5.2.37"
    echo -e "\tCopyright (C) 2024-present Tina-lel"
    echo -e "\tCopyright (C) 2024-present Justus0405"
    echo -e ""
    echo -e "This program may be freely redistributed under"
    echo -e "the terms of the GNU General Public License v2.0"
    exit 0
    ;;
"INSTALL")
    if [[ $2 == "" ]]; then
        echo -e "${ERROR} no targets specified (use -h for help)"
        exit 1
    fi

    # This checks wether or not the specified package name is available at the
    # remote repo via an http code (200 means downloadable, so continue)
    echo -ne "${INFO} Checking Package availability... "
    AVAILABILITY=$(curl -o /dev/null --silent -Iw "%{http_code}" "$REPO/$2.tar.gz")
    echo -e "$AVAILABILITY"
    echo -ne "${INFO} Checking Checksum availability... "
    AVAILABILITY_MD5=$(curl -o /dev/null --silent -Iw "%{http_code}" "$REPO/hashes/$2.md5")
    echo -e "$AVAILABILITY_MD5"
    if [[ "$AVAILABILITY" != "200" || "$AVAILABILITY_MD5" != "200" ]]; then
        echo -e "${ERROR} Cant download package or checksum"
        exit 1
    fi

    echo -e ""

    read -rp "Do you wish to install $2? [Y/n] " confirm
    case "$confirm" in
    [yY][eE][sS] | [yY])
        mkdir -p "$WORKING_DIR"
        cd "$WORKING_DIR" || {
            echo -e "${ERROR} could not enter temp path"
            exit 1
        }

        echo -e "${INFO} Downloading package..."
        curl -s -o "$2.tar.gz" "$REPO/$2.tar.gz"
        curl -s -o "$2.md5" "$REPO/hashes/$2.md5"

        echo -e "${INFO} Verifying checksum..."
        md5sum --quiet -c "$2.md5" || {
            echo -e "${ERROR} Checksum missmatch"
            exit 1
        }

        echo -e "${INFO} Extracting package..."
        tar -xzf "$2.tar.gz"
        PKG_DIR="$WORKING_DIR/$2"

        echo -e "${INFO} Loading build info..."
        source "$PKG_DIR/pkg_info"

        if [[ "$DOWNLOAD" == "true" ]]; then
            echo -e "${INFO} Downloading source..."
            DOWNLOAD_SRC
        fi

        if [[ "$COMPILE" == "true" ]]; then
            echo -e "${INFO} Compiling source..."
            COMPILE_SRC
        fi

        echo -e "${INFO} Installing package..."
        INSTALL_PKG

        echo -e "${INFO} Cleaning up..."
        cd "$WORKING_DIR" || {
            echo -e "${ERROR} could not enter temp path"
            exit 1
        }
        rm -rf "$2.tar.gz" "$2.md5" "$2"
        ;;
    *)
        echo -e "${RED}Aborted.${ENDCOLOR}"
        ;;
    esac
    ;;
"REMOVE")
    echo -e "OH MY GOD"
    ;;
"UPGRADE")
    echo -e "HELP"
    ;;
"SEARCH")
    curl --silent "$REPO"/ | grep -o 'href=".*">' | sed -e "s/href=\"//g" | sed -e 's/">//g' | tail -n +2 | grep -v "hashes/" | grep "${PACKAGE_NAMES[0]}"
    ;;
"LIST")
    echo -e "Listing of $REPO\n"
    curl --silent "$REPO"/ | grep -o 'href=".*">' | sed -e "s/href=\"//g" | sed -e 's/">//g' | tail -n +2 | grep -v "hashes/"
    ;;
esac
